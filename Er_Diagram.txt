erDiagram
    ROLES {
        int id PK
        string role_name UK
        string descripted
    }

    ADMIN {
        int id PK
        string username UK
        string email UK
        string hashed_password
        datetime created_at
        datetime updated_at
        string role_name FK
    }

    CUSTOMER {
        int id PK
        string username
        string email UK
        string phone_number
        string hashed_password
        string address
        datetime created_at
        datetime updated_at
        string status
        string role_name FK
    }

    SELLER {
        int id PK
        string username
        string email UK
        string phone_number UK
        string hashed_password
        string business_name
        string business_type
        string business_address
        string kyc_document_type
        bigint kyc_document_number
        string bank_account_name
        bigint bank_account_number
        string bank_name
        string bank_branch
        datetime created_at
        datetime updated_at
        string status
        boolean is_verified
        string role_name FK
    }

    PRODUCTS {
        int id PK
        string product_name
        string url_slug UK
        string product_category
        string description
        string image_url
        string status
        int seller_id FK
        datetime created_at
        datetime updated_at
    }

    PRODUCT_VARIANTS {
        int id PK
        int product_id FK
        string sku UK
        string color
        string size
        decimal price
        int stock_quantity
        boolean is_active
        datetime created_at
        datetime updated_at
    }

    PRODUCT_IMAGES {
        int id PK
        int product_id FK
        string image_url
        boolean is_primary
        int sort_order
        datetime created_at
    }
    CARTS {
        int id PK
        int buyer_id FK
        string status
        datetime created_at
        datetime updated_at
    }

    CART_ITEMS {
        int id PK
        int cart_id FK
        int variant_id FK
        int quantity
        datetime created_at
        datetime updated_at
    }

    ORDERS {
        int id PK
        int buyer_id FK
        string status
        decimal total_price
        decimal shipping_fee
        decimal discount_amount
        decimal tax_amount
        datetime order_placed
        datetime delivered_at
    }

    ORDER_ITEMS {
        int id PK
        int order_id FK
        int variant_id FK
        int quantity
        decimal unit_price_snapshot
        decimal line_total
    }

    PAYMENTS {
        int id PK
        int order_id FK
        string method
        string status
        decimal amount
        string provider_ref
        datetime created_at
        datetime updated_at
    }

    ADDRESSES {
        int id PK
        int customer_id FK
        string full_name
        string phone_number
        string province
        string city
        string street
        string postal_code
        boolean is_default
        datetime created_at
        datetime updated_at
    }

    SHIPMENTS {
        int id PK
        int order_id FK
        string carrier
        string tracking_number
        string status
        datetime shipped_at
        datetime delivered_at
        datetime created_at
        datetime updated_at
    }

    SELLER_VERIFICATIONS {
        int id PK
        int seller_id FK
        string status
        int reviewed_by_admin_id FK
        string review_note
        datetime created_at
        datetime updated_at
    }

    PRODUCT_APPROVALS {
        int id PK
        int product_id FK
        string status
        int reviewed_by_admin_id FK
        string reason
        datetime created_at
        datetime updated_at
    }

    AUDIT_LOGS {
        int id PK
        string actor_type
        int actor_id
        string action
        string entity_type
        int entity_id
        string metadata_json
        datetime created_at
    }


    %% Role relationships
    ROLES ||--o{ ADMIN : "role_name"
    ROLES ||--o{ CUSTOMER : "role_name"
    ROLES ||--o{ SELLER : "role_name"

    %% Commerce relationships
    CUSTOMER ||--o{ ORDERS : "places"
    ORDERS ||--o{ ORDER_ITEM : "contains"
    PRODUCTS ||--o{ ORDER_ITEM : "included_in"
    SELLER ||--o{ PRODUCTS : "lists"

    %% Reviews
    PRODUCTS ||--o{ REVIEW : "receives"
    CUSTOMER ||--o{ REVIEW : "writes"

    %% Note: REFRESH_TOKENS.owner_id is polymorphic (Admin/Seller/Customer),
    %% so it has no enforced FK relationship in the schema.

















## Optimized Database Design – Hotel Booking System

This design reflects **production-grade optimization**, normalization, and booking-safety patterns used in real hotel platforms (Booking.com–style systems).

---

## 1. Core Optimization Principles Applied

1. **3NF normalization** (no redundant data)
2. **Availability stored per room per date** (prevents double booking)
3. **Minimal joins for search paths**
4. **Write-heavy operations are transactional**
5. **Read-heavy operations are index-optimized**
6. **Money & pricing snapshotted at booking time**

---

## 2. Final Entity List (Optimized)

### 2.1 users

```
users
-----
id (PK)
name
email (UNIQUE)
password_hash
role  (USER | ADMIN | HOTEL_ADMIN)
created_at
```

Indexes:

* UNIQUE(email)

---

### 2.2 hotels

```
hotels
------
id (PK)
name
city
address
latitude
longitude
rating
owner_id (FK → users.id)
created_at
```

Indexes:

* city
* owner_id

---

### 2.3 room_types (Optimization: avoid enum rigidity)

```
room_types
----------
id (PK)
name (Single, Double, Suite)
max_occupancy
```

---

### 2.4 rooms

```
rooms
-----
id (PK)
hotel_id (FK → hotels.id)
room_type_id (FK → room_types.id)
room_number
floor
base_price
is_active
```

Constraints:

* UNIQUE(hotel_id, room_number)

Indexes:

* hotel_id
* room_type_id

---

### 2.5 room_availability (MOST IMPORTANT TABLE)

```
room_availability
-----------------
id (PK)
room_id (FK → rooms.id)
available_date
is_available
price_override (nullable)
```

Constraints:

* UNIQUE(room_id, available_date)

Indexes:

* room_id, available_date
* available_date

Purpose:

* Prevents double booking
* Enables fast availability search

---

### 2.6 bookings

```
bookings
--------
id (PK)
user_id (FK → users.id)
hotel_id (FK → hotels.id)
status (PENDING | CONFIRMED | CANCELLED)
check_in_date
check_out_date
total_amount
created_at
```

Indexes:

* user_id
* hotel_id
* status

---

### 2.7 booking_rooms (Pricing snapshot)

```
booking_rooms
-------------
id (PK)
booking_id (FK → bookings.id)
room_id (FK → rooms.id)
price_per_night
```

Reason:

* Preserves historical price even if room price changes

---

### 2.8 payments

```
payments
--------
id (PK)
booking_id (FK → bookings.id)
amount
currency
status (INITIATED | SUCCESS | FAILED | REFUNDED)
payment_provider
transaction_ref
created_at
```

Indexes:

* booking_id
* transaction_ref

---

## 3. FULL ER DIAGRAM (Textual – Interview Ready)

```
[USERS]
   |
   | 1
   |------< owns
   |           n
[HOTELS]
   |
   | 1
   |------< contains
   |           n
[ROOMS] >------ 1 [ROOM_TYPES]
   |
   | 1
   |------< has
   |           n
[ROOM_AVAILABILITY]

[USERS]
   |
   | 1
   |------< makes
   |           n
[BOOKINGS] >------ 1 [HOTELS]
   |
   | 1
   |------< includes
   |           n
[BOOKING_ROOMS] >------ 1 [ROOMS]

[BOOKINGS]
   |
   | 1
   |------< paid_by
   |           n
[PAYMENTS]
```

---

## 4. Booking Availability Algorithm (Optimized)

### Search Query (Indexed)

```sql
SELECT r.id
FROM rooms r
JOIN room_availability ra ON r.id = ra.room_id
WHERE r.hotel_id = :hotelId
AND ra.available_date BETWEEN :checkIn AND :checkOut - INTERVAL '1 day'
AND ra.is_available = true
GROUP BY r.id
HAVING COUNT(*) = :numberOfNights;
```

Why this is optimal:

* Uses composite indexes
* No joins on bookings table
* Linear scan avoided

---

## 5. Locking Strategy (Critical for Scale)

During booking:

```sql
SELECT * FROM room_availability
WHERE room_id = :roomId
AND available_date BETWEEN :checkIn AND :checkOut
FOR UPDATE;
```

Guarantees:

* No race condition
* No double booking

---

## 6. Why This Design Is "Production Grade"

| Concern        | How It’s Solved                 |
| -------------- | ------------------------------- |
| Double booking | Availability table + DB locking |
| Price changes  | Snapshot in booking_rooms       |
| Search speed   | Precomputed availability        |
| Scalability    | Read-heavy tables indexed       |
| Audit          | Immutable booking records       |

---

## 7. How to Explain This in Interviews

> "We model availability as a per-room per-day entity and lock rows transactionally during booking to guarantee consistency under concurrent access. Pricing is snapshotted at booking time to preserve historical accuracy."

That explanation alone is **senior-backend level**.

---

## 8. Recommended Next Steps

1. Draw this ER diagram visually (Lucidchart / Draw.io)
2. Implement schema in PostgreSQL
3. Generate availability for 12 months ahead
4. Build transactional booking service

---

If you want next, I can:

* Convert this into **SQL DDL**
* Provide **Spring Boot JPA entities**
* Optimize further for **multi-hotel chains**
* Add **dynamic pricing & seasons**

Tell me how far you want to push this.
